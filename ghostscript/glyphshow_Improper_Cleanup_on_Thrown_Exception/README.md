# glyphshow_Improper_Cleanup_on_Thrown_Exception

## Brief
`op_show_finish_setup` and`op_show_continue_pop` are always paired. When errors occur, `op_show_continue_pop` need to cleane up the "estack_mark" made by `op_show_finish_setup`.

## Reproduce

```
echo 'clippath { '$(printf "0 %.0s" {1..799})' /ff glyphshow 0 0 } stopped' | gs
```

**Backtrace**:
```
#0  0x0000555555e0e25c in op_show_finish_setup (i_ctx_p=0x5555579417e8, penum=0x555557bb9d40, npop=0x1, endproc=0x0) at ./psi/zchar.c:652
#1  0x0000555555d97534 in zglyphshow (i_ctx_p=0x5555579417e8) at ./psi/zcharx.c:68
#2  0x0000555555dd6846 in do_call_operator (op_proc=0x555555d9748b <zglyphshow>, i_ctx_p=0x5555579417e8) at ./psi/interp.c:91
#3  0x0000555555dd9f34 in interp (pi_ctx_p=0x55555790e0d0, pref=0x7fffffffd0a0, perror_object=0x7fffffffd410) at ./psi/interp.c:1380
#4  0x0000555555dd7315 in gs_call_interp (pi_ctx_p=0x55555790e0d0, pref=0x7fffffffd310, user_errors=0x1, pexit_code=0x7fffffffd408, perror_object=0x7fffffffd410) at ./psi/interp.c:531
#5  0x0000555555dd70a2 in gs_interpret (pi_ctx_p=0x55555790e0d0, pref=0x7fffffffd310, user_errors=0x1, pexit_code=0x7fffffffd408, perror_object=0x7fffffffd410) at ./psi/interp.c:488
#6  0x0000555555dc54ee in gs_main_interpret (minst=0x55555790e030, pref=0x7fffffffd310, user_errors=0x1, pexit_code=0x7fffffffd408, perror_object=0x7fffffffd410) at ./psi/imain.c:257
#7  0x0000555555dc7118 in gs_main_run_string_end (minst=0x55555790e030, user_errors=0x1, pexit_code=0x7fffffffd408, perror_object=0x7fffffffd410) at ./psi/imain.c:945
```

## Analysis
1. In `zglyphshow` function (` zcharx.c: 68`), first call `op_show_finish_setup`, then `op_show_find()` -> `op_show_find_index()` , at the file `zchar.c: 884` search `estack_mark` on the exec_stack , at this time there is no "estack_mark" in the execution stack, and return 0;
```c
static uint
op_show_find_index(i_ctx_t *i_ctx_p)
{
    ref_stack_enum_t rsenum;
    uint count = 0;
    ref_stack_enum_begin(&rsenum, &e_stack);
    do {
        es_ptr ep = rsenum.ptr;
        uint size = rsenum.size;
        for (ep += size - 1; size != 0; size--, ep--, count++)
            if (r_is_estack_mark(ep) && estack_mark_index(ep) == es_show) // <---- There!
                return count;
    } while (ref_stack_enum_next(&rsenum));
    return 0;		/* no mark */
}
```

2. Then `op_show_finish_setup (zchar.c: 664)` adds the`estack_mark` structure to the execution stack, and return to `zglyphshow`;
```c
int
op_show_finish_setup(i_ctx_t *i_ctx_p, gs_text_enum_t * penum, int npop,
                     op_proc_t endproc /* end procedure */ )
{
    gs_text_enum_t *osenum = op_show_find(i_ctx_p);
    es_ptr ep = esp + snumpush; // <---- There!
    ......
    if (osenum == NULL && !(penum->text.operation & (TEXT_FROM_GLYPHS | TEXT_FROM_SINGLE_GLYPH))) {
        int ft = igs->root_font->FontType;
        if ((ft >= ft_CID_encrypted && ft <= ft_CID_TrueType) || ft == ft_CID_bitmap)
            return_error(gs_error_typecheck);
    }
    make_mark_estack(ep - (snumpush - 1), es_show, op_show_cleanup); // <---- There!
    if (endproc == NULL)
        endproc = finish_show;
    make_null(&esslot(ep));
    make_int(&esodepth(ep), ref_stack_count_inline(&o_stack) - npop); /* Save stack depth for */
    make_int(&esddepth(ep), ref_stack_count_inline(&d_stack));        /* correct interrupt processing */
    make_int(&esgslevel(ep), igs->level);
    make_null(&essfont(ep));
    make_null(&esrfont(ep));
    make_op_estack(&eseproc(ep), endproc);
    /* The text enumerators are always allocated in local VM */
    make_struct(ep, iimemory_local->space, penum);
    esp = ep;
    return 0;
}
```

3. `zglyphshow (zcharx.c:72)` calls `op_show_continue_pop()`, enter the `op_show_continue_dispatch` function, at this time, the value of `code` is 1, so it moves to the` case text_process_render (zchar.c:730)`, at line 763: `push (2)`, due to the `P + 2> Top` at this time, triggers`gs_error_stackoverowrow`, so functions ` zglyphshow`, `do_call_operator`,` interp` all returned `0xFFFFFFFFFFF0` (psi/interp.c:531)

```c
int
op_show_continue_dispatch(i_ctx_t *i_ctx_p, int npop, int code)
{
    os_ptr op = osp - npop;
    gs_text_enum_t *penum = senum;
    ......
        case TEXT_PROCESS_RENDER: {
            gs_font *pfont = gs_currentfont(igs);
            font_data *pfdata = pfont_data(pfont);
            gs_char chr = gs_text_current_char(penum);
            gs_glyph glyph = gs_text_current_glyph(penum);
            push(2); // <---- There!
            /*
            do {
                if ( (op += (2)) > (((i_ctx_p->op_stack).stack).top) ) {
                    ((i_ctx_p->op_stack).stack).requested = (2);
                    return (gs_error_stackoverflow);  // <---- There!
                }
                else (((i_ctx_p->op_stack).stack).p) = op;
            } while (0)
             */
            op[-1] = pfdata->dict;	/* push the font */
            /*
    ......
```

4. At `gs_call_interp():652`, `ref_stack_extend` finished, and passed `r_is_proc`, Then re-execute`zglyphshow` and trigger the bug.
```c
static int
gs_call_interp(i_ctx_t **pi_ctx_p, ref * pref, int user_errors,
               int *pexit_code, ref * perror_object)
{
    ......
    code = interp(pi_ctx_p, epref, perror_object);
    i_ctx_p = *pi_ctx_p;
    if (!r_has_type(&i_ctx_p->error_object, t__invalid)) {
        *perror_object = i_ctx_p->error_object;
        make_t(&i_ctx_p->error_object, t__invalid);
    }
    ......
    switch (code) {
        ......
            case gs_error_stackoverflow:
            if (ref_stack_extend(&o_stack, o_stack.requested) >= 0) {   /* We can't just re-execute the object, because */
                /* it might be a procedure being pushed as a */
                /* literal.  We check for this case specially. */
                doref = *perror_object;
                if (r_is_proc(&doref)) { // <---- There!
                    *++osp = doref;
                    make_null_proc(&doref);
                }
                epref = &doref;
                goto again;
            }
            ccode = copy_stack(i_ctx_p, &o_stack, 0, &saref);
            if (ccode < 0)
                return ccode;
            ref_stack_clear(&o_stack);
            *++osp = saref;
            break;
        ......
    }
    ......
}
```

## Reference
https://bugs.ghostscript.com/show_bug.cgi?id=707485
https://git.ghostscript.com/?p=ghostpdl.git;a=commitdiff;h=74bd45a92ae

## Credit
ghost461 @Knownsec404team
